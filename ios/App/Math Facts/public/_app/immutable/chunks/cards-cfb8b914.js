import{w}from"./index-e45dfa94.js";var n=(i=>(i.Addition="Addition",i.Multiplication="Multiplication",i.Subtraction="Subtraction",i.Division="Division",i))(n||{}),c=(i=>(i.Addition="+",i.Multiplication="&times;",i.Subtraction="-",i.Division="&div;",i))(c||{});function a(i,t,s){return s.indexOf(i)===t}function h(i){for(let t=i.length-1;t>0;t--){const s=Math.floor(Math.random()*(t+1));[i[t],i[s]]=[i[s],i[t]]}return i}class l{constructor(t,s,e,r){this.term1=t,this.term2=s,this.answer=e,this.score=r,this.highlight=!1,this.answerList=this.buildAnswers()}buildAnswers(){return[-4,-3,-2,-1]}update(t){this.score=t}terms(){return h([this.term1,this.term2])}answers(){return this.answerList}isHighlighted(){return this.highlight}static buildCard(t,s,e){return{}}}class u extends l{buildAnswers(){return h(h([Math.max(1,this.term1-1)*this.term2,(this.term1+1)*this.term2,this.term1*(this.term2+1),this.term1*Math.max(this.term2-1,1),Math.round(this.term1*this.term2+this.term2/2),Math.round(this.term1*this.term2+this.term1/2),this.term1*this.term2+2,this.term1*this.term2+1]).filter(a).filter(t=>t!==this.answer).slice(0,3).concat([this.term1*this.term2]))}static buildCard(t,s,e){return new u(t,s,t*s,e)}}class m extends l{buildAnswers(){return h(h([this.term1*2+this.term2,this.term1+this.term2*2,this.term1+this.term2-1,this.term1+this.term2+1,this.term1+this.term2+2]).filter(a).filter(t=>t!==this.answer).slice(0,3).concat([this.term1+this.term2]))}static buildCard(t,s,e){return new m(t,s,t+s,e)}}class d extends l{buildAnswers(){return h(h([this.term1*2-this.term2,Math.round(this.term1-this.term2/2),this.term1-this.term2-1,this.term1-this.term2+1,this.term1-this.term2+2]).filter(a).filter(t=>t!==this.answer).slice(0,3).concat([this.term1-this.term2]))}terms(){return[this.term1,this.term2]}static buildCard(t,s,e){return new d(t+s,s,t,e)}}class f extends l{buildAnswers(){return h(h([this.term1*2/this.term1,this.term1/this.term2-1,this.term1/this.term2+1,this.term1-this.term2+1,this.term1+this.term2-1]).filter(a).filter(t=>t!==this.answer).slice(0,3).concat([this.term1/this.term2]))}terms(){return[this.term1,this.term2]}static buildCard(t,s,e){return new f(t*s,s,t,e)}}class g{constructor(t){this.scores=[],this.cards=[],this.startTime=new Date().getTime(),this.operator=t,this.correct=0,this.missed=0,this.scored=[],this.unscored=[]}encode(){const t=[];for(let s=0;s<this.scores.length;s++)t.push(this.scores[s].score);return t}buildDeck(){this.cards=[],this.scored=[],this.unscored=[],this.scores.forEach(t=>{for(let s=0;s<5-t.score;s++)t.score==0?this.unscored.push(t):this.scored.push(t)}),this.next()}next(){let t=this.unscored;if(t.length>0)for(;t.length<this.scored.length;)t=t.concat(this.unscored);return this.cards=h(t.concat(this.scored)),!0}insert(t){this.scores.push(t),this.cards.push(t)}update(t,s){const e=new Date().getTime()-this.startTime;this.startTime=new Date().getTime();const r=this.scores.find(o=>o.term1==t.term1&&o.term2==t.term2);return r&&t.answer==s?(this.correct++,r.score=Math.max(Math.min(4,Math.ceil(5-Math.min(e/1e3,5))),1)):r&&(this.missed++,r.score=0),this.buildDeck(),console.log("Elapsed time: "+e,t.answer,s,this.cards.length),!0}current(){return this.cards.length>0?this.cards[0]:this.scores[0]}}class D{constructor(){this.Decks={};const t={};Object.keys(c).forEach((e,r)=>{t[e]=Array(78).fill(0),typeof localStorage<"u"&&(t[e]=localStorage.getItem(e)?JSON.parse(localStorage.getItem(e)):Array(78).fill(0)),this.Decks[e]=new g(c[e])});let s=0;for(let e=1;e<=12;e++)for(let r=e;r<=12;r++)this.Decks[n.Multiplication].insert(u.buildCard(e,r,t[n.Multiplication][s])),this.Decks[n.Addition].insert(m.buildCard(e,r,t[n.Addition][s])),this.Decks[n.Division].insert(f.buildCard(e,r,t[n.Division][s])),this.Decks[n.Subtraction].insert(d.buildCard(e,r,t[n.Subtraction][s])),s++;console.log("Building decks ..."),Object.keys(c).forEach((e,r)=>{this.Decks[e].buildDeck()})}save(){Object.keys(c).forEach((t,s)=>{localStorage.setItem(t,JSON.stringify(this.Decks[t].encode()))})}}function p(){const i=new D,{subscribe:t,set:s,update:e}=w(i);return{subscribe:t,answer(r,o,b){e(()=>(i.Decks[r].update(o,b),i.save(),i))},next(r){e(()=>(i.Decks[r].next(),i))},current(r){return i.Decks[r].current()}}}const A=p();export{A as c};
